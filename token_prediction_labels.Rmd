---
title: "Token classification"
output:
  html_document: default
  pdf_document: default
params:
  chain: "H"
  fine_tuning_region: "FULL"
  predict_region: "FULL"
  max_sequences: 0
  models: ""
  data_path: !r file.path(getwd(), "data")
---
```{r setup, warning = FALSE, message = FALSE, cache = FALSE}
if(!require("ggplot2")){
  install.packages("ggplot2")
}
library(ggplot2)

if(!require("dplyr")) {
  install.packages("dplyr")
}
library(dplyr)

if(!require("arrow")) {
  install.packages("arrow")
}
library(arrow)

if(!require("gridExtra")) {
  install.packages("gridExtra")
}
library(gridExtra)

if(!require("glue")) {
  install.packages("glue")
}
library(glue)

# For mixedsort()
if(!require("gtools")) {
  install.packages("gtools")
}

if(!require("tidyr")) {
  install.packages("tidyr")
}
library(tidyr)

if(!require("stringr")) {
  install.packages("stringr")
}
library(stringr)

knitr::opts_chunk$set(fig.width=14, fig.height=16)
```

```{r plot_token_prediction, cache = FALSE}
plot_token_prediction <- function(model_name, is_ft) {
  chain <- params$chain
  fine_tuning_region <- params$fine_tuning_region
  predict_region <- params$predict_region
  data_path <- params$data_path

  ft_pt <- if (is_ft) "FT" else "PT"
  token_pred_data_path <- file.path(
    data_path,
    glue("token_prediction_{model_name}_{chain}_{fine_tuning_region}_",
         "{predict_region}_{ft_pt}.parquet"))
  data <- read_parquet(token_pred_data_path)

  df <- data[, (names(data) %in%
             c("iden_code", "positions", "labels", "predicted_labels"))]

  pivoted_df <- df %>%
    separate_rows(positions, labels, predicted_labels, sep = ",") %>%
    mutate(labels = as.integer(labels),
           predicted_labels = as.integer(predicted_labels))

  aggregated_df <- pivoted_df %>%
    group_by(iden_code, positions) %>%
    summarise(
      labels = sum(labels, na.rm = TRUE),
      predicted_labels = sum(predicted_labels, na.rm = TRUE),
      .groups = 'drop'
    )

  if (params$max_sequences > 0)
    aggregated_df <- aggregated_df %>%
    filter(iden_code %in% (unique(iden_code) %>% head(params$max_sequences)))

  # Fill in missing values
  aggregated_df <- tidyr::complete(
    aggregated_df,
    positions = unique(aggregated_df$positions),
    iden_code = unique(aggregated_df$iden_code)
  )

  aggregated_df$pred_labels_diff <- with(
    aggregated_df,
    ifelse(labels == predicted_labels, labels,
    ifelse(predicted_labels == 1 & labels != predicted_labels, 2,
    ifelse(predicted_labels == 0 & labels != predicted_labels, 3,
    ifelse(predicted_labels == -100 & labels != predicted_labels, 4, NA)))))

  aggregated_df$color_pred_labels_diff <- case_when(
    aggregated_df$pred_labels_diff == 2 ~ "false-positive",
    aggregated_df$pred_labels_diff == 3 ~ "false-negative",
    aggregated_df$pred_labels_diff == 4 ~ "false-missing",
    aggregated_df$pred_labels_diff == 1 ~ "binding",
    aggregated_df$pred_labels_diff == 0 ~ "non-binding",
    aggregated_df$pred_labels_diff < 0 ~ "missing",
    is.na(aggregated_df$pred_labels_diff) ~ "missing",
  )

  # Sort legend values
  aggregated_df$color_pred_labels_diff <- factor(
    aggregated_df$color_pred_labels_diff, levels = c(
      "binding", "non-binding", "false-positive",
      "false-negative", "false-missing", "missing"))

  # Sort positions by number followed by iCode
  aggregated_df$positions <- factor(
    aggregated_df$positions, levels = mixedsort(
      unique(aggregated_df$positions)))

  position_breaks <- levels(aggregated_df$positions)[
    grepl("[A-Z]$", levels(aggregated_df$positions)) |
      (suppressWarnings(as.numeric(levels(
        aggregated_df$positions)) %% 5 == 0)) |
      (suppressWarnings(as.numeric(levels(aggregated_df$positions)) == 1))]

  position_labels <- sapply(levels(aggregated_df$positions), function(x)
    if (x %in% position_breaks)
      x
    else
      "")

  p <- ggplot(aggregated_df,
               aes(x = positions, y = iden_code,
                   fill = color_pred_labels_diff)) +
    geom_tile() +
    scale_fill_manual(values = c(
        "binding" = "#ffbe4f",
        "non-binding" = "#0ea7b5",
        "missing" = "#6bd2db",
        "false-positive" = "#766df6",
        "false-negative" = "#f66d6d"
      ),
      labels = c(
        binding = "Correct binding prediction",
        "non-binding" = "Correct non-binding prediction",
        missing = "Missing sequence position",
        "false-positive" = "False positive",
        "false-negative" = "False negative"
    )) +
    labs(
      title = glue("Predicted labels - {model_name} - {fine_tuning_region} - ",
                   "{predict_region} - {ft_pt}"),
      x = glue("Chain: {chain} - {predict_region}"),
      y = "Sequences",
      fill = "Color"
    ) +
    scale_x_discrete(
      labels = position_labels, guide = guide_axis(n.dodge = 2)) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(
        angle = 90,
        hjust = 1,
        vjust = 0.5,
        size = 5
      )
    )
  print(p)
}
```

```{r plot_models, cache = FALSE, fig.height = 4}
models <- str_split(params$models, ",")[[1]]

for (model in models) {
  print(model)
  plot_token_prediction(model, FALSE)
  plot_token_prediction(model, TRUE)
}
```
