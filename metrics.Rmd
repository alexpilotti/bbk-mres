---
title: "Metrics"
output:
  html_document: default
  pdf_document: default
params:
  chain: "H"
  models: ""
  include_svm: True
  include_unfiltered: True
  include_averages: True
  data_path: !r file.path(getwd(), "data")
---
```{r setup, warning = FALSE, message = FALSE, cache = FALSE}
if(!require("jsonlite")) {
  install.packages("jsonlite")
}
library(jsonlite)

if(!require("ggplot2")) {
  install.packages("ggplot2")
}
library(ggplot2)

if(!require("stringr")) {
  install.packages("stringr")
}
library(stringr)

if(!require("glue")){
  install.packages("glue")
}
library(glue)

if(!require("dplyr")){
  install.packages("dplyr")
}
library(dplyr)

if(!require("patchwork")){
  install.packages("patchwork")
}
library(patchwork)

knitr::opts_chunk$set(
  fig.width = 8,
  fig.height = 5.2,
  dpi = 300,
  fig.align = "center"
)
```

```{r functions, cache = FALSE}
data_path <- params$data_path
chain <- params$chain

PT <- "PT"
FT <- "FT"
PT_SVM <- "PT_SVM"
PT_SVM_shuffled <- "PT_SVM_shuffled"

PLM_NUM_PARAMS_BASE <- 1000^4

load_json_files <- function(training, filtered = TRUE) {
  metrics <- data.frame()
  model_names <- str_split(params$models, ",")[[1]]
  filtered_str <- ifelse(filtered, "", "_NF")

  for (model_name in model_names) {
    json_data <- fromJSON(file.path(
      data_path,
      glue(
        "predict_metrics_{model_name}_{chain}_{training}{filtered_str}.json")))

    if (!"num_parameters" %in% names(json_data)) {
      json_data$num_parameters <- NA
      json_data$test_loss <- NA
    }

    if (grepl("ESM", model_name)) {
      # Simple hack to group ESM models together
      json_data$num_parameters <- json_data$num_parameters + PLM_NUM_PARAMS_BASE
    }

    json_data <- data.frame(
      precision = json_data$precision,
      recall = json_data$recall,
      specificity = json_data$specificity,
      f1 = json_data$f1,
      fpr = json_data$fpr,
      ap = json_data$ap,
      balanced_accuracy = json_data$balanced_accuracy,
      auc = json_data$auc,
      mcc = json_data$mcc,
      test_loss = json_data$test_loss,
      model = model_name,
      num_parameters = json_data$num_parameters,
      training = glue(training, filtered_str)
    )

    metrics <- rbind(metrics, json_data)
  }

  return(metrics)
}

load_data <- function(filtered) {
  metrics <- data.frame()

  metrics_pt <- load_json_files(PT, filtered)
  metrics_ft <- load_json_files(FT, filtered)
  metrics <- rbind(metrics, metrics_pt, metrics_ft)

  if (params$include_svm) {
    metrics_svm <- load_json_files(PT_SVM, filtered)
    metrics_svm_shuffle <- load_json_files(PT_SVM_shuffled, filtered)
    metrics <- rbind(metrics, metrics_svm, metrics_svm_shuffle)
  }
  metrics
}

compute_averages <- function(metrics) {
   # Set a high number to plot the AVG column after all models
  avg_num_parameters <- 1e100
  df_avg <-
      metrics %>%
        group_by(training) %>%
        summarise(across(where(is.numeric) & !num_parameters,
                         ~ mean(.x, na.rm = TRUE)),
                  .groups = "drop") %>%
        mutate(model = "AVG", num_parameters = avg_num_parameters)
  df_avg
}

metrics <- load_data(TRUE)
if (params$include_unfiltered) {
  metrics <- rbind(metrics, load_data(FALSE))
}

if (params$include_averages) {
  metrics_avg <- compute_averages(metrics)
  metrics <- bind_rows(metrics, metrics_avg)
}

plot_bracket <- function(x1, x2, y_bar = 0.45, tip = 0.18,
                         label = NULL, gap = 0.08, lw = 0.6, text_vjust = 0,
                         text_size = 3) {
  list(
    annotate("segment", x = x1, xend = x2, y = y_bar, yend = y_bar,
             linewidth = lw),
    annotate("segment", x = x1, xend = x1, y = y_bar, yend = y_bar - tip,
             linewidth = lw),
    annotate("segment", x = x2, xend = x2, y = y_bar, yend = y_bar - tip,
             linewidth = lw),
    if (!is.null(label))
      annotate("text", x = (x1 + x2)/2, y = y_bar + gap, label = label,
               vjust = text_vjust, size = text_size)
  )
}

plot_data <- function(metrics, metric_name) {
  data_range <- max(metrics[metric_name]) - min(metrics[metric_name])
  binwidth_value <- data_range / 30

  if (nchar(metric_name) < 6) {
    y_label <- toupper(metric_name)
  } else {
    y_label <- tools::toTitleCase(gsub("_", " ", metric_name))
  }

  rows_order <- c("FT", "FT_NF", "PT_SVM", "PT_SVM_NF", "PT_SVM_shuffled",
                  "PT_SVM_shuffled_NF", "PT", "PT_NF")

  p <- ggplot(metrics, aes(x = reorder(model, num_parameters,
                                       FUN = function(x) mean(x, na.rm = TRUE)),
                           y = factor(training, levels = rev(rows_order)),
                           fill = .data[[metric_name]])) +
  geom_tile(color = "black") +
  geom_text(aes(label = sprintf("%.2f", .data[[metric_name]])),
            color = "black", size = 3) +
  coord_fixed() +
  scale_fill_gradient(low = "#FFFFBF", high = "#1A9850") +
  scale_y_discrete(position = "right", labels = c(
    PT = "Pre-trained",
    FT = "Fine-tuned",
    PT_SVM  = "Pre-trained + SVM",
    PT_SVM_shuffled = "Pre-trained + SVM (shuffled)",
    PT_NF = "Pre-trained (non clustered)",
    FT_NF = "Fine-tuned (non clustered)",
    PT_SVM_NF  = "Pre-trained + SVM (non clustered)",
    PT_SVM_shuffled_NF = "Pre-trained + SVM (shuffled, non clustered)"
  )) +
  theme_minimal() +
  theme(
    legend.position = "left",
    plot.title = element_text(
      hjust = 0.5,
      face = "bold",
      size = 16
    ),
    # Needed otherwise the leftmost X text label gets cropped
    plot.margin = margin(l = 20),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.x = element_text(color = "black", angle = 45,
                               hjust = 1, vjust = 1),
    axis.text.y = element_text(color = "black")
  ) +
  labs(
    title = y_label,
    x = NULL,
    y = NULL,
    fill = NULL
  ) +
  guides(fill = guide_colorbar(title.position = "top",
                               barwidth = unit(0.5, "lines"),
                               barheight = unit(5, "lines")))

  model_num_params <- metrics %>%
                      filter(!is.na(num_parameters)) %>%
                      distinct(model, num_parameters) %>%
                      arrange(num_parameters)
  last_ablm_idx <- model_num_params %>%
                   summarise(
                     idx = sum(num_parameters < PLM_NUM_PARAMS_BASE)) %>%
                   pull(idx)
  # Don't include the AVG column
  last_plm_idx <- nrow(model_num_params) - 1

  # TODO: fix brackets layout with a different number of models
  if (!is.na(last_ablm_idx) && last_plm_idx == 11) {
    p_brackets <- ggplot(metrics, aes(x = model, y = 0)) +
      geom_blank() +
      coord_cartesian(ylim = c(0, 1), clip = "off") +
      theme_void() +
      plot_bracket(1, last_ablm_idx,
                   y_bar = -1.05, tip = 0.2, gap = 0.08, label = "AbLMs") +
      plot_bracket(last_ablm_idx + 1, last_plm_idx,
                   y_bar = -1.05, tip = 0.2, gap = 0.08, label = "PLMs")

    p <- p_brackets / p + plot_layout(heights = unit(c(12, 1), c("mm", "null")))
  }
  p
}
```

```{r precision, cache = FALSE}
plot_data(metrics, "precision")
```

```{r specificity, cache = FALSE}
plot_data(metrics, "specificity")
```

```{r recall, cache = FALSE}
plot_data(metrics, "recall")
```

```{r fpr, cache = FALSE}
plot_data(metrics, "fpr")
```

```{r f1, cache = FALSE}
plot_data(metrics, "f1")
```

```{r ap, cache = FALSE}
plot_data(metrics, "ap")
```

```{r balanced_accuracy, cache = FALSE}
plot_data(metrics, "balanced_accuracy")
```

```{r auc, cache = FALSE}
plot_data(metrics, "auc")
```

```{r mcc, cache = FALSE}
plot_data(metrics, "mcc")
```
