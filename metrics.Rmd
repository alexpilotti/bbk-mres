---
title: "Metrics"
output:
  html_document: default
  pdf_document: default
params:
  chain: "H"
  models: ""
  include_svm: False
  include_unfiltered: True
  include_averages: True
  data_path: !r file.path(getwd(), "data")
---
```{r setup, warning = FALSE, message = FALSE, cache = FALSE}
if(!require("jsonlite")) {
  install.packages("jsonlite")
}
library(jsonlite)

if(!require("ggplot2")) {
  install.packages("ggplot2")
}
library(ggplot2)

if(!require("stringr")) {
  install.packages("stringr")
}
library(stringr)

if(!require("glue")){
  install.packages("glue")
}
library(glue)

if(!require("dplyr")){
  install.packages("dplyr")
}
library(dplyr)
```

```{r functions, cache = FALSE}
data_path <- params$data_path
chain <- params$chain

PT <- "PT"
FT <- "FT"
PT_SVM <- "PT_SVM"
PT_SVM_shuffled <- "PT_SVM_shuffled"

load_json_files <- function(training, filtered = TRUE) {
  metrics <- data.frame()
  model_names <- str_split(params$models, ",")[[1]]
  filtered_str <- ifelse(filtered, "", "_NF")

  for (model_name in model_names) {
    json_data <- fromJSON(file.path(
      data_path,
      glue(
        "predict_metrics_{model_name}_{chain}_{training}{filtered_str}.json")))

    if (!"num_parameters" %in% names(json_data)) {
      json_data$num_parameters <- NA
      json_data$test_loss <- NA
    }

    if (grepl("ESM", model_name)) {
      # Simple hack to group ESM models together
      json_data$num_parameters <- json_data$num_parameters + 1000^4
    }

    json_data <- data.frame(
      precision = json_data$precision,
      recall = json_data$recall,
      specificity = json_data$specificity,
      f1 = json_data$f1,
      fpr = json_data$fpr,
      apr = json_data$apr,
      balanced_accuracy = json_data$balanced_accuracy,
      auc = json_data$auc,
      mcc = json_data$mcc,
      test_loss = json_data$test_loss,
      model = model_name,
      num_parameters = json_data$num_parameters,
      training = glue(training, filtered_str)
    )

    metrics <- rbind(metrics, json_data)
  }

  return(metrics)
}

load_data <- function(filtered) {
  metrics <- data.frame()

  metrics_pt <- load_json_files(PT, filtered)
  metrics_ft <- load_json_files(FT, filtered)
  metrics <- rbind(metrics, metrics_pt, metrics_ft)

  if (params$include_svm) {
    metrics_svm <- load_json_files(PT_SVM, filtered)
    metrics_svm_shuffle <- load_json_files(PT_SVM_shuffled, filtered)
    metrics <- rbind(metrics, metrics_svm, metrics_svm_shuffle)
  }
  metrics
}

compute_averages <- function(metrics) {
   # Set a high number to plot the AVG column after all models
  avg_num_parameters <- 1e100
  df_avg <-
      metrics %>%
        group_by(training) %>%
        summarise(across(where(is.numeric) & !num_parameters,
                         ~ mean(.x, na.rm = TRUE)),
                  .groups = "drop") %>%
        mutate(model = "AVG", num_parameters = avg_num_parameters)
  df_avg
}

metrics <- load_data(TRUE)
if (params$include_unfiltered) {
  metrics <- rbind(metrics, load_data(FALSE))
}

if (params$include_averages) {
  metrics_avg <- compute_averages(metrics)
  metrics <- bind_rows(metrics, metrics_avg)
}

plot_data <- function(metrics, metric_name) {
  data_range <- max(metrics[metric_name]) - min(metrics[metric_name])
  binwidth_value <- data_range / 30
  y_label = tools::toTitleCase(gsub("_", " ", metric_name))

  rows_order <- c("FT", "FT_NF", "PT_SVM", "PT_SVM_NF", "PT_SVM_shuffled",
                  "PT_SVM_shuffled_NF", "PT", "PT_NF")

  p <- ggplot(metrics, aes(x = reorder(model, num_parameters,
                                       FUN = function(x) mean(x, na.rm = TRUE)),
                           y = factor(training, levels = rev(rows_order)),
                           fill = .data[[metric_name]])) +
  geom_tile(color = "black") +
  geom_text(aes(label = sprintf("%.2f", .data[[metric_name]])),
            color = "black", size = 3) +
  coord_fixed() +
  scale_fill_gradient(low = "#FFFFBF", high = "#1A9850") +
  scale_y_discrete(position = "right", labels = c(
    PT = "Pre-trained",
    FT = "Fine-tuned",
    PT_SVM  = "Pre-trained + SVM",
    PT_SVM_shuffled = "Pre-trained + SVM (shuffled)",
    PT_NF = "Pre-trained (non clustered)",
    FT_NF = "Fine-tuned (non clustered)",
    PT_SVM_NF  = "Pre-trained + SVM (non clustered)",
    PT_SVM_shuffled_NF = "Pre-trained + SVM (shuffled, non clustered)"
  )) +
  theme_minimal() +
  theme(
    legend.position = "left",
    plot.title = element_text(
      hjust = 0.5,
      face = "bold",
      size = 16
    ),
    # Needed otherwise the leftmost X text label gets cropped
    plot.margin = margin(l = 20),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.x = element_text(color = "black", angle = 45,
                               hjust = 1, vjust = 1),
    axis.text.y = element_text(color = "black")
  ) +
  labs(
    title = y_label,
    x = NULL,
    y = NULL,
    fill = NULL
  ) +
  guides(fill = guide_colorbar(title.position = "top",
                               barwidth = unit(0.5, "lines"),
                               barheight = unit(5, "lines")))
  p
}
```

```{r precision, cache = FALSE}
plot_data(metrics, "precision")
```

```{r specificity, cache = FALSE}
plot_data(metrics, "specificity")
```

```{r recall, cache = FALSE}
plot_data(metrics, "recall")
```

```{r fpr, cache = FALSE}
plot_data(metrics, "fpr")
```

```{r f1, cache = FALSE}
plot_data(metrics, "f1")
```

```{r apr, cache = FALSE}
plot_data(metrics, "apr")
```

```{r balanced_accuracy, cache = FALSE}
plot_data(metrics, "balanced_accuracy")
```

```{r auc, cache = FALSE}
plot_data(metrics, "auc")
```

```{r mcc, cache = FALSE}
plot_data(metrics, "mcc")
```
